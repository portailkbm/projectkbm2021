{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect, useRef } from \"react\";\n\nfunction useOuterClick(callback) {\n  _s();\n\n  // Initialize mutable ref, which stores callback\n  var callbackRef = useRef(); // returned to client, who marks \"border\" element\n\n  var innerRef = useRef(); // Update callback on each render, so second useEffect has access to current value\n\n  useEffect(function () {\n    callbackRef.current = callback;\n  });\n  useEffect(function () {\n    document.addEventListener(\"click\", handleClick);\n    return function () {\n      return document.removeEventListener(\"click\", handleClick);\n    };\n\n    function handleClick(e) {\n      if (innerRef.current && callbackRef.current && !innerRef.current.contains(e.target)) callbackRef.current(e);\n    }\n  }, []);\n  return innerRef;\n}\n\n_s(useOuterClick, \"SI2bQFKsSK58vQtCJjSO19wM6GE=\");\n\nexport default useOuterClick;","map":{"version":3,"sources":["C:/Users/enliv/Desktop/appstack-react-2-master/src/hooks/useOuterClick.tsx"],"names":["useEffect","useRef","useOuterClick","callback","callbackRef","innerRef","current","document","addEventListener","handleClick","removeEventListener","e","contains","target"],"mappings":";;AAAA,SAASA,SAAT,EAAoBC,MAApB,QAAkC,OAAlC;;AAEA,SAASC,aAAT,CAAuBC,QAAvB,EAAiC;AAAA;;AAChC;AACA,MAAMC,WAAwC,GAAGH,MAAM,EAAvD,CAFgC,CAGhC;;AACA,MAAMI,QAAqC,GAAGJ,MAAM,EAApD,CAJgC,CAMhC;;AACAD,EAAAA,SAAS,CAAC,YAAM;AACfI,IAAAA,WAAW,CAACE,OAAZ,GAAsBH,QAAtB;AACA,GAFQ,CAAT;AAIAH,EAAAA,SAAS,CAAC,YAAM;AACfO,IAAAA,QAAQ,CAACC,gBAAT,CAA0B,OAA1B,EAAmCC,WAAnC;AACA,WAAO;AAAA,aAAMF,QAAQ,CAACG,mBAAT,CAA6B,OAA7B,EAAsCD,WAAtC,CAAN;AAAA,KAAP;;AACA,aAASA,WAAT,CAAqBE,CAArB,EAAwB;AACvB,UACCN,QAAQ,CAACC,OAAT,IACAF,WAAW,CAACE,OADZ,IAEA,CAACD,QAAQ,CAACC,OAAT,CAAiBM,QAAjB,CAA0BD,CAAC,CAACE,MAA5B,CAHF,EAKCT,WAAW,CAACE,OAAZ,CAAoBK,CAApB;AACD;AACD,GAXQ,EAWN,EAXM,CAAT;AAaA,SAAON,QAAP;AACA;;GAzBQH,a;;AA2BT,eAAeA,aAAf","sourcesContent":["import { useEffect, useRef } from \"react\";\r\n\r\nfunction useOuterClick(callback) {\r\n\t// Initialize mutable ref, which stores callback\r\n\tconst callbackRef: React.MutableRefObject<any> = useRef();\r\n\t// returned to client, who marks \"border\" element\r\n\tconst innerRef: React.MutableRefObject<any> = useRef();\r\n\r\n\t// Update callback on each render, so second useEffect has access to current value\r\n\tuseEffect(() => {\r\n\t\tcallbackRef.current = callback;\r\n\t});\r\n\r\n\tuseEffect(() => {\r\n\t\tdocument.addEventListener(\"click\", handleClick);\r\n\t\treturn () => document.removeEventListener(\"click\", handleClick);\r\n\t\tfunction handleClick(e) {\r\n\t\t\tif (\r\n\t\t\t\tinnerRef.current &&\r\n\t\t\t\tcallbackRef.current &&\r\n\t\t\t\t!innerRef.current.contains(e.target)\r\n\t\t\t)\r\n\t\t\t\tcallbackRef.current(e);\r\n\t\t}\r\n\t}, []);\r\n\r\n\treturn innerRef;\r\n}\r\n\r\nexport default useOuterClick;\r\n"]},"metadata":{},"sourceType":"module"}