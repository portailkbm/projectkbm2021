{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useEffect } from \"react\";\nimport usePalette from \"../hooks/usePalette\";\nimport { defaults } from \"react-chartjs-2\";\n\nvar ChartJsDefaults = function ChartJsDefaults() {\n  _s();\n\n  var palette = usePalette();\n  useEffect(function () {\n    defaults.global.defaultFontColor = palette[\"gray-600\"];\n    defaults.global.defaultFontFamily = \"'Poppins', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\";\n  }, [palette]);\n  return null;\n};\n\n_s(ChartJsDefaults, \"n6hXLMY0ZYAqIJNeS6ydGgUr810=\", false, function () {\n  return [usePalette];\n});\n\n_c = ChartJsDefaults;\nexport default ChartJsDefaults; // Rounded corners for barcharts\n\nwindow.Chart.elements.Rectangle.prototype.draw = function () {\n  var ctx = this._chart.ctx;\n  var vm = this._view;\n  var left, right, top, bottom, signX, signY, borderSkipped;\n  var borderWidth = vm.borderWidth;\n  var cornerRadius = 10;\n\n  if (!vm.horizontal) {\n    // bar\n    left = vm.x - vm.width / 2;\n    right = vm.x + vm.width / 2;\n    top = vm.y;\n    bottom = vm.base;\n    signX = 1;\n    signY = bottom > top ? 1 : -1;\n    borderSkipped = vm.borderSkipped || \"bottom\";\n  } else {\n    // horizontal bar\n    left = vm.base;\n    right = vm.x;\n    top = vm.y - vm.height / 2;\n    bottom = vm.y + vm.height / 2;\n    signX = right > left ? 1 : -1;\n    signY = 1;\n    borderSkipped = vm.borderSkipped || \"left\";\n  } // Canvas doesn't allow us to stroke inside the width so we can\n  // adjust the sizes to fit if we're setting a stroke on the line\n\n\n  if (borderWidth) {\n    // borderWidth shold be less than bar width and bar height.\n    var barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\n    borderWidth = borderWidth > barSize ? barSize : borderWidth;\n    var halfStroke = borderWidth / 2; // Adjust borderWidth when bar top position is near vm.base(zero).\n\n    var borderLeft = left + (borderSkipped !== \"left\" ? halfStroke * signX : 0);\n    var borderRight = right + (borderSkipped !== \"right\" ? -halfStroke * signX : 0);\n    var borderTop = top + (borderSkipped !== \"top\" ? halfStroke * signY : 0);\n    var borderBottom = bottom + (borderSkipped !== \"bottom\" ? -halfStroke * signY : 0); // not become a vertical line?\n\n    if (borderLeft !== borderRight) {\n      top = borderTop;\n      bottom = borderBottom;\n    } // not become a horizontal line?\n\n\n    if (borderTop !== borderBottom) {\n      left = borderLeft;\n      right = borderRight;\n    }\n  }\n\n  ctx.beginPath();\n  ctx.fillStyle = vm.backgroundColor;\n  ctx.strokeStyle = vm.borderColor;\n  ctx.lineWidth = borderWidth; // Corner points, from bottom-left to bottom-right clockwise\n  // | 1 2 |\n  // | 0 3 |\n\n  var corners = [[left, bottom], [left, top], [right, top], [right, bottom]]; // Find first (starting) corner with fallback to 'bottom'\n\n  var borders = [\"bottom\", \"left\", \"top\", \"right\"];\n  var startCorner = borders.indexOf(borderSkipped, 0);\n\n  if (startCorner === -1) {\n    startCorner = 0;\n  }\n\n  function cornerAt(index) {\n    return corners[(startCorner + index) % 4];\n  } // Draw rectangle from 'startCorner'\n\n\n  var corner = cornerAt(0);\n  ctx.moveTo(corner[0], corner[1]);\n\n  for (var i = 1; i < 4; i++) {\n    corner = cornerAt(i);\n    var width = corners[2][0] - corners[1][0];\n    var height = corners[0][1] - corners[1][1];\n    var x = corners[1][0];\n    var y = corners[1][1];\n    var radius = cornerRadius; // Fix radius being too large\n\n    if (radius > height / 2) {\n      radius = height / 2;\n    }\n\n    if (radius > width / 2) {\n      radius = width / 2;\n    }\n\n    var lastVisible = 0;\n\n    for (var findLast = 0, findLastTo = this._chart.data.datasets.length; findLast < findLastTo; findLast++) {\n      if (!this._chart.getDatasetMeta(findLast).hidden) {\n        lastVisible = findLast;\n      }\n    }\n\n    var rounded = this._datasetIndex === lastVisible;\n\n    if (rounded) {\n      ctx.moveTo(x + radius, y);\n      ctx.lineTo(x + width - radius, y);\n      ctx.quadraticCurveTo(x + width, y, x + width, y + radius);\n      ctx.lineTo(x + width, y + height);\n      ctx.lineTo(x, y + height);\n      ctx.lineTo(x, y + radius);\n      ctx.quadraticCurveTo(x, y, x + radius, y);\n    } else {\n      ctx.moveTo(x, y);\n      ctx.lineTo(x + width, y);\n      ctx.lineTo(x + width, y + height);\n      ctx.lineTo(x, y + height);\n      ctx.lineTo(x, y);\n    }\n  }\n\n  ctx.fill();\n\n  if (borderWidth) {\n    ctx.stroke();\n  }\n};\n\nvar _c;\n\n$RefreshReg$(_c, \"ChartJsDefaults\");","map":{"version":3,"sources":["C:/Users/enliv/Desktop/appstack-react-2-master/src/utils/ChartJsDefaults.tsx"],"names":["useEffect","usePalette","defaults","ChartJsDefaults","palette","global","defaultFontColor","defaultFontFamily","window","Chart","elements","Rectangle","prototype","draw","ctx","_chart","vm","_view","left","right","top","bottom","signX","signY","borderSkipped","borderWidth","cornerRadius","horizontal","x","width","y","base","height","barSize","Math","min","abs","halfStroke","borderLeft","borderRight","borderTop","borderBottom","beginPath","fillStyle","backgroundColor","strokeStyle","borderColor","lineWidth","corners","borders","startCorner","indexOf","cornerAt","index","corner","moveTo","i","radius","lastVisible","findLast","findLastTo","data","datasets","length","getDatasetMeta","hidden","rounded","_datasetIndex","lineTo","quadraticCurveTo","fill","stroke"],"mappings":"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","sourcesContent":["import { useEffect } from \"react\";\r\n\r\nimport usePalette from \"../hooks/usePalette\";\r\nimport { defaults } from \"react-chartjs-2\";\r\n\r\nconst ChartJsDefaults = () => {\r\n\tconst palette = usePalette();\r\n\r\n\tuseEffect(() => {\r\n\t\tdefaults.global.defaultFontColor = palette[\"gray-600\"];\r\n\t\tdefaults.global.defaultFontFamily =\r\n\t\t\t\"'Poppins', 'Helvetica Neue', 'Helvetica', 'Arial', sans-serif\";\r\n\t}, [palette]);\r\n\r\n\treturn null;\r\n};\r\n\r\nexport default ChartJsDefaults;\r\n\r\n// Rounded corners for barcharts\r\n(window as any).Chart.elements.Rectangle.prototype.draw = function () {\r\n\tconst ctx = this._chart.ctx;\r\n\tconst vm = this._view;\r\n\tlet left, right, top, bottom, signX, signY, borderSkipped;\r\n\tlet borderWidth = vm.borderWidth;\r\n\tlet cornerRadius = 10;\r\n\r\n\tif (!vm.horizontal) {\r\n\t\t// bar\r\n\t\tleft = vm.x - vm.width / 2;\r\n\t\tright = vm.x + vm.width / 2;\r\n\t\ttop = vm.y;\r\n\t\tbottom = vm.base;\r\n\t\tsignX = 1;\r\n\t\tsignY = bottom > top ? 1 : -1;\r\n\t\tborderSkipped = vm.borderSkipped || \"bottom\";\r\n\t} else {\r\n\t\t// horizontal bar\r\n\t\tleft = vm.base;\r\n\t\tright = vm.x;\r\n\t\ttop = vm.y - vm.height / 2;\r\n\t\tbottom = vm.y + vm.height / 2;\r\n\t\tsignX = right > left ? 1 : -1;\r\n\t\tsignY = 1;\r\n\t\tborderSkipped = vm.borderSkipped || \"left\";\r\n\t}\r\n\r\n\t// Canvas doesn't allow us to stroke inside the width so we can\r\n\t// adjust the sizes to fit if we're setting a stroke on the line\r\n\tif (borderWidth) {\r\n\t\t// borderWidth shold be less than bar width and bar height.\r\n\t\tconst barSize = Math.min(Math.abs(left - right), Math.abs(top - bottom));\r\n\t\tborderWidth = borderWidth > barSize ? barSize : borderWidth;\r\n\t\tconst halfStroke = borderWidth / 2;\r\n\t\t// Adjust borderWidth when bar top position is near vm.base(zero).\r\n\t\tconst borderLeft =\r\n\t\t\tleft + (borderSkipped !== \"left\" ? halfStroke * signX : 0);\r\n\t\tconst borderRight =\r\n\t\t\tright + (borderSkipped !== \"right\" ? -halfStroke * signX : 0);\r\n\t\tconst borderTop = top + (borderSkipped !== \"top\" ? halfStroke * signY : 0);\r\n\t\tconst borderBottom =\r\n\t\t\tbottom + (borderSkipped !== \"bottom\" ? -halfStroke * signY : 0);\r\n\t\t// not become a vertical line?\r\n\t\tif (borderLeft !== borderRight) {\r\n\t\t\ttop = borderTop;\r\n\t\t\tbottom = borderBottom;\r\n\t\t}\r\n\t\t// not become a horizontal line?\r\n\t\tif (borderTop !== borderBottom) {\r\n\t\t\tleft = borderLeft;\r\n\t\t\tright = borderRight;\r\n\t\t}\r\n\t}\r\n\r\n\tctx.beginPath();\r\n\tctx.fillStyle = vm.backgroundColor;\r\n\tctx.strokeStyle = vm.borderColor;\r\n\tctx.lineWidth = borderWidth;\r\n\r\n\t// Corner points, from bottom-left to bottom-right clockwise\r\n\t// | 1 2 |\r\n\t// | 0 3 |\r\n\tconst corners = [\r\n\t\t[left, bottom],\r\n\t\t[left, top],\r\n\t\t[right, top],\r\n\t\t[right, bottom],\r\n\t];\r\n\r\n\t// Find first (starting) corner with fallback to 'bottom'\r\n\tconst borders = [\"bottom\", \"left\", \"top\", \"right\"];\r\n\tlet startCorner = borders.indexOf(borderSkipped, 0);\r\n\tif (startCorner === -1) {\r\n\t\tstartCorner = 0;\r\n\t}\r\n\r\n\tfunction cornerAt(index) {\r\n\t\treturn corners[(startCorner + index) % 4];\r\n\t}\r\n\r\n\t// Draw rectangle from 'startCorner'\r\n\tlet corner = cornerAt(0);\r\n\tctx.moveTo(corner[0], corner[1]);\r\n\r\n\tfor (var i = 1; i < 4; i++) {\r\n\t\tcorner = cornerAt(i);\r\n\r\n\t\tconst width = corners[2][0] - corners[1][0];\r\n\t\tconst height = corners[0][1] - corners[1][1];\r\n\t\tconst x = corners[1][0];\r\n\t\tconst y = corners[1][1];\r\n\r\n\t\tlet radius = cornerRadius;\r\n\r\n\t\t// Fix radius being too large\r\n\t\tif (radius > height / 2) {\r\n\t\t\tradius = height / 2;\r\n\t\t}\r\n\t\tif (radius > width / 2) {\r\n\t\t\tradius = width / 2;\r\n\t\t}\r\n\r\n\t\tlet lastVisible = 0;\r\n\t\tfor (\r\n\t\t\tlet findLast = 0, findLastTo = this._chart.data.datasets.length;\r\n\t\t\tfindLast < findLastTo;\r\n\t\t\tfindLast++\r\n\t\t) {\r\n\t\t\tif (!this._chart.getDatasetMeta(findLast).hidden) {\r\n\t\t\t\tlastVisible = findLast;\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tlet rounded = this._datasetIndex === lastVisible;\r\n\r\n\t\tif (rounded) {\r\n\t\t\tctx.moveTo(x + radius, y);\r\n\t\t\tctx.lineTo(x + width - radius, y);\r\n\t\t\tctx.quadraticCurveTo(x + width, y, x + width, y + radius);\r\n\t\t\tctx.lineTo(x + width, y + height);\r\n\t\t\tctx.lineTo(x, y + height);\r\n\t\t\tctx.lineTo(x, y + radius);\r\n\t\t\tctx.quadraticCurveTo(x, y, x + radius, y);\r\n\t\t} else {\r\n\t\t\tctx.moveTo(x, y);\r\n\t\t\tctx.lineTo(x + width, y);\r\n\t\t\tctx.lineTo(x + width, y + height);\r\n\t\t\tctx.lineTo(x, y + height);\r\n\t\t\tctx.lineTo(x, y);\r\n\t\t}\r\n\t}\r\n\r\n\tctx.fill();\r\n\tif (borderWidth) {\r\n\t\tctx.stroke();\r\n\t}\r\n};\r\n"]},"metadata":{},"sourceType":"module"}